import * as s from "./secondary"
import {client, OWNER_ID, BOT_ID, userDB, visibleServers} from "./bot"
import {imgDatabaseURL} from "./config"
import {hiragana, katakana, kanalat, kanji} from "./japdata"

import got from "got"
import Cheerio from "cheerio"
import Intl from "intl"
import fs from "fs"

const Canvas = require('canvas')
Canvas.registerFont('fonts/KosugiMaru-Regular.ttf', { family: 'KosugiMaru' })

export const commands = {
	Help: {
		r: /^(—Ö[–µ—ç]–ª–ø|–ø–æ–º–æ(—â—å|–≥–∏)|–∫–æ–º–∞–Ω–¥—ã|help|comm?ands?)[.!]?$/,
		v: true,
		f (msg) {
			const helpLines = [
				"–ß—Ç–æ–±—ã —Å–ø—Ä–æ—Å–∏—Ç—å —á—Ç–æ-–ª–∏–±–æ, –æ–±—Ä–∞—Ç–∏—Å—å –∫–æ –º–Ω–µ –ø–æ –∏–º–µ–Ω–∏ –∏ –≤–≤–µ–¥–∏ –∫–æ–º–∞–Ω–¥—É.",
				"–ù–∞–ø—Ä–∏–º–µ—Ä: `—Å–±–æ—Ç –∏–º–≥ –∫—Ä–µ–∞—Ç–∏–≤ –Ω–∞–º–∏—è` (–≤ –õ–° –º–æ–∂–Ω–æ –±–µ–∑ –æ–±—Ä–∞—â–µ–Ω–∏—è)",
				`–ü—É—Å—Ç–∏—Ç—å –º–µ–Ω—è –Ω–∞ —Å–≤–æ–π —Å–µ—Ä–≤–µ—Ä –º–æ–∂–Ω–æ –ø–æ [—ç—Ç–æ–π —Å—Å—ã–ª–∫–µ](https://discordapp.com/api/oauth2/authorize?client_id=${BOT_ID}&scope=bot&permissions=0).`
			]
			const helpEmbed = {
				color: 0x7486C2,
				title: "–ü—Ä–∏–≤–µ—Ç, –º–µ–Ω—è –∑–æ–≤—É—Ç –°—Ç–∏–ª–ª–ë–æ—Ç <:tuturuMetal:601419582837751810>",
				description: helpLines.join("\n"),
				fields: [
					{
						name: "–∏–º–≥ [—Ç–µ–≥–∏ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª]",
						value: "–†–∞–Ω–¥–æ–º–Ω–∞—è –ø–∏–∫—á–∞ –∏–∑ [–ì–∞–ª–µ—Ä–µ–∏](https://stilltest.tk/gallery/).",
						inline: true
					},
					{
						name: "–∞–≤–∞ [–Ω–∏–∫–Ω–µ–π–º –∏–ª–∏ –∞–π–¥–∏ —é–∑–µ—Ä–∞]",
						value: "–ì–ª—è–Ω—É—Ç—å —á—å—é-—Ç–æ –∞–≤–∫—É.",
						inline: true
					},
					{
						name: "<–æ–ø–∏—Å–∞–Ω–∏–µ –ø–∏–∫—á–∏> + –ø—Ä–∏–∫—Ä–µ–ø–ª—ë–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ üìé",
						value: "–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å —Å–≤–æ–π —Å–∫—Ä–∏–Ω—à–æ—Ç –≤ –ì–∞–ª–µ—Ä–µ—é (—Ç–æ–ª—å–∫–æ –≤ –õ–°, [–ø—Ä–∏–º–µ—Ä –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è](https://i.imgur.com/kus289H.png)).\n–ï—Å–ª–∏ —è –ø–æ—Å—Ç–∞–≤–∏–ª –≤ –æ—Ç–≤–µ—Ç üìÆ - –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç."
					},
					{
						name: "—Ö–æ—É–º—Å—Ç–∞–∫ [–Ω–æ–º–µ—Ä_—Å—Ç—Ä–∞–Ω–∏—Ü—ã]",
						value: "–ü–æ—á–∏—Ç–∞—Ç—å [–∫–æ–º–∏–∫—Å](https://www.homestuck.com/story).",
						inline: true
					},
					{
						name: "–ø–∞–ª–∏—Ç—Ä–∞ + –ø—Ä–∏–∫—Ä–µ–ø–ª—ë–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ üìé",
						value: "–°—á–∏—Ç–∞—Ç—å —Ü–≤–µ—Ç–∞ —Å –∫–∞—Ä—Ç–∏–Ω–∫–∏.",
						inline: true
					},
					{
						name: "–∫–∞–Ω–∞ <—Ö–∏—Ä–∞–≥–∞–Ω–∞|–∫–∞—Ç–∞–∫–∞–Ω–∞>",
						value: "Êó•Êú¨Ë™û„ÇíÂ≠¶„Å∂!",
						inline: true
					},
					{
						name: "–∫–æ–≥–¥–∞ <—á—Ç–æ-—Ç–æ —Å–ª—É—á–∏—Ç—Å—è>",
						value: "–£–∑–Ω–∞–π, –∫–æ–≥–¥–∞ —ç—Ç–æ —Å–ª—É—á–∏—Ç—Å—è!",
						inline: true
					},
					{
						name: "–∂–¥ <–≤–æ–ø—Ä–æ—Å —Å –æ—Ç–≤–µ—Ç–æ–º –¥–∞/–Ω–µ—Ç>",
						value: "–û–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –º—É–¥—Ä–æ—Å—Ç–∏ [–ñ–µ–ª–µ–∑–Ω–æ–π –î–≤–µ—Ä–∏](https://randomforum.ru/threads/6469/).",
						inline: true
					}
				]
			}
		
			msg.channel.send({embed: helpEmbed})
		}
	},
	Ping: {
		r: /^(–ø–∏–Ω–≥|ping)[.!]?$/,
		v: true,
		f (msg) {
			let pongText = "üèì –ü–æ–Ω–≥!"
			msg.channel.send(pongText)
				.then((pong) => {
					let userTime = msg.createdTimestamp / 1000
					let botTime = pong.createdTimestamp / 1000
					let pongTime = (botTime - userTime).toFixed(3)
					pong.edit(`${pongText} ${pongTime} —Å–µ–∫`)
				})
				.catch(error => console.log(error))
		}
	},
	Destroy: {
		r: /^(–¥–µ—Å—Ç—Ä–æ–π)[.!]?$/,
		v: true,
		f (msg) {
			if (msg.author.id == OWNER_ID) {
				console.log("Destroying client...")
				msg.author.send("üõå üåå").then(() => {
					client.destroy().then(() => {
						console.log("Exiting process...")
						process.exit()
					})
				})
			}
		}
	},
	Img: {
		r: /^(–ø–∏–∫—á–∞|–∏–º–≥|–∫–∞—Ä—Ç–∏–Ω–∫?–∞|–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ|–≥–∞–ª–µ—Ä–µ—è|img|image|pic(ture)?|gallery)[.!,:]?$/,
		v: true,
		async f (msg, args) {
			let argsText = ""
		
			if (args.length > 0) {
				argsText = args.join(",")
				argsText = "?tags=" + encodeURIComponent(argsText)
			}
		
			try {
				let { body: imageInfo } = await got(`${imgDatabaseURL}random/${argsText}`, { json: true })
				if (imageInfo.error) throw Error(imageInfo.error)
			
				let imageExtension = imageInfo.tags.includes("gif") ? "gif" : "png"
				let imagePreview = `https://i.imgur.com/${imageInfo.id}t.jpg`
				await s.getMainColorFromImage(imagePreview, color => {
					msg.channel.send({
						embed: {
							color: color,
							author: {
								name: imageInfo.title,
								icon_url: "https://i.imgur.com/5EOhj0z.png",
								url: `https://stilltest.tk/gallery/#${imageInfo.id}`
							},
							description: `–¢–µ–≥–∏: ${imageInfo.tags.join(", ")}`
								+ (imageInfo.date ? `\n–î–∞—Ç–∞: ${imageInfo.date}` : ""),
							image: {
								url: `https://i.imgur.com/${imageInfo.id}.${imageExtension}`
							}
						}
					})
				})
			} catch (err) {
				await msg.react("604015450304806952")
			}
		}
	},
	Send: {
		r: /^(–æ—Ç–ø—Ä–∞–≤(–∏—Ç)?—å|–ø—Ä–µ–¥–ª–æ–∂–∏(—Ç—å)?|–ø—Ä–∏—à–ª–∏|–ø—Ä–∏—Å–ª–∞—Ç—å|send)$/,
		async f (msg, args, msgSimplifiedOrigCase) {
			let imageParamsArray = msgSimplifiedOrigCase.match(/\S+ (\S+) ([\s\S]+)/)
		
			if (!imageParamsArray) {
				msg.react("üìú")
				msg.channel.send("–ß—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É, –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∫ –Ω–µ–π –æ–ø–∏—Å–∞–Ω–∏–µ, –¥–∞—Ç—É –∏ –º–µ—Å—Ç–æ.")
				return
			}
		
			let startLink = imageParamsArray[1]
		
			let imgurParams
			let discordLink = ""
		
			let imageLink = startLink
			let imageID = ""
		
			if (!imageLink.includes("//i.imgur.com/")) {
				try {
					imgurParams = await s.sendAttachmentToImgur(imageLink)
					if (imgurParams) {
						discordLink = startLink
						imageLink = imgurParams[0]
						imageID = imgurParams[1]
					}
				} catch (err) {
					if (err.statusCode === 400) {
						msg.channel.send("–ü–æ—Ö–æ–∂–µ, —á—Ç–æ —Å—Å—ã–ª–∫–∞ –Ω–µ –ø–æ–Ω—Ä–∞–≤–∏–ª–∞—Å—å –ò–º–≥—É—Ä—É.")
						return
					}
				}
			} else {
				try {
					imageID = imageLink.match(/\/\/i\.imgur\.com\/(.+)\./)[1]
				} catch (err) {}
			}
		
			let imageDate = ""
			if (discordLink) {
				let ogURLParts = discordLink.split("/")
				let ogImgName = ogURLParts[ogURLParts.length - 1]
				if (ogImgName.match(/\d{4}-\d{2}-\d{2}/)) {
					imageDate = ogImgName.match(/\d{4}-\d{2}-\d{2}/)[0]
				}
		
				discordLink = `<${discordLink}>\n`
			}
		

			let dateRE = /\d{4}[-_\.\/\\]\d{2}[-_\.\/\\]\d{2}/i
			let takenByRE = /(?:(?:—Å–∫—Ä–∏–Ω(?:—à–æ—Ç)? )?—Å–Ω—è—Ç–æ?| ?by|takenby|from)\s*:?\s*(\S+)/i
			let tagsRE = /(?:tags|—Ç[–µ–∞—ç]–≥–∏)(?:\s+)?:?/i
			
			let imageNote = imageParamsArray[2]
			let customDate = ""
			let takenBy, imageTitle, tagsRaw
			
			try {
				let dateMatch = imageNote.match(dateRE)
				imageNote = imageNote.split(dateMatch[0]).join(" ")
				customDate = dateMatch[0].trim().replace(/[_\.\/\\]/g, "-")
			} catch (err) {}

			try {
				let takenByMatch = imageNote.match(takenByRE)
				imageNote = imageNote.split(takenByMatch[0]).join(" ")
				takenBy = s.trimPunc(takenByMatch[1])
			} catch (err) {}

			try {
				tagsRaw = s.trimPunc(imageNote.split(tagsRE)[1])
			} catch (err) {}

			imageTitle = s.trimPunc(imageNote.split(tagsRE)[0])

			let imageTags = []
			if (tagsRaw) {
				imageTags = tagsRaw.toLowerCase().replace(/^\s+/g, "").split(/[,;\s]+/)
			}
			let tagsToClean = []
			for (let i in imageTags) {
				let minusMatch = imageTags[i].match(/^-(.+)/)
				if (minusMatch) {
					tagsToClean.push(minusMatch[1])
				}
			}
			imageTags.unshift("screenshot", "minecraft")
			for (let i in tagsToClean) {
				s.removeElementsByValue(imageTags, tagsToClean[i], `-${tagsToClean[i]}`)
			}
			let imageTagsText = imageTags.map(x=>'"'+x+'"').join(', ')
		
			let imageJSON = `\`\`\`json\n\t"${imageID}": {\n\t\t"title": ${JSON.stringify(imageTitle)},\n\t\t"date": "${(imageDate) ? imageDate : customDate}",\n\t\t"takenBy": "${(takenBy) ? takenBy : msg.author.username}",\n\t\t"big": true,\n\t\t"tags": [${imageTagsText}]\n\t},\n\`\`\``
		
			client.channels.get("526441608250392577").send("–û—Ç " + msg.author.tag + ":\n" + discordLink + imageLink + "\n" + imageJSON)
				.then(() => {
					msg.react("üìÆ")
				})
				.catch(error => console.log(error))
		}
	},
	React: {
		r: /^([–øp—Är]|–ø–æ—Å—Ç–∞–≤—å|–æ—Ç—Ä–µ–∞–≥–∏—Ä—É–π|—Ä–µ–∞–∫—Ü–∏—è|react(ion)?)$/,
		f (msg, args) {
			s.autoreact(msg, args, false) // —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–Ω–µ—Å–µ–Ω–∞, —Ç–∞–∫ –∫–∞–∫ –∫ –Ω–µ–π –Ω—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∏ –±–µ–∑ –∫–æ–º–∞–Ω–¥—ã
		}
	},
	EmojiList: {
		r: /^(—ç(–º–æ(–¥[–∂–∑]|–∂)–∏)?|—Å–º–∞–π–ª(–∏–∫–∏|—ã)|emoji(s|list)?)[.!]?$/,
		v: true,
		f (msg, args, msgSimplifiedOrigCase, usedArrowButton) {
			let defaultGuildId = "540145900526501899"
			let fromWhichServer = client.guilds.get(defaultGuildId)
			let askedServer = s.getGuild(args[0])
			let numberOfCurrentGuild = visibleServers.indexOf(defaultGuildId) + 1
		
			let goRight = false
			let goLeft = false
			if (args[0] == "+") {
				goRight = true
			} else if (args[0] == "-") {
				goLeft = true
			} else if (askedServer) {
				fromWhichServer = askedServer
				numberOfCurrentGuild = visibleServers.indexOf(askedServer.id) + 1
			}

			let possiblePrevId = msg.content.match(/(\d{17,20})\`$/)
		
			if (usedArrowButton && possiblePrevId) {
				let prevServer = possiblePrevId[1]
				let p = visibleServers.indexOf(prevServer)
				if (p > -1) {
					let n
					if (goRight) {
						n = p + 1
					} else if (goLeft) {
						n = p - 1
					}
					if (n < 0) {
						n = visibleServers.length - 1
					} else if (n >= visibleServers.length) {
						n = 0
					}
		
					numberOfCurrentGuild = n + 1
					fromWhichServer = client.guilds.get(visibleServers[n])
				}
			}
		
			let emServ = fromWhichServer
			if (emServ && emServ.emojis.size) {
				let embed = {
					color: 0xD4A940,
					fields: [
						{
							name: "1-1:",
							value: ""
						}
					],
					footer: {
						text: `üìñ ${numberOfCurrentGuild}/${visibleServers.length}`
					}
				}
		
				let i = 0
				let f = 0
				let emojiDesc = "–î–æ—Å—Ç—É–ø–Ω—ã–µ —ç–º–æ–¥–∂–∏:\n" + emServ.name + " `" + emServ.id + "`"
				let emojiList = []
		
				let fieldStart = 1
		
				emServ.emojis.forEach(key => {
					let prefix = "<:"
					let postfix = ">" + " `" + key.name + "`"
					if (key.animated) {
						prefix = "<a:"
					}
					if (++i % 10 == 1) {
						prefix = "\n" + prefix
					}
					let emojiInfo = prefix + key.name + ":" + key.id + postfix
					emojiList.push(emojiInfo)
					let emListText = emojiList.join(" ")
		
					if (f >= 6) {
						return
					} else if (emListText.length < 993) {
						embed.fields[f].name = fieldStart + "-" + i + ":"
						embed.fields[f].value = emListText
					} else {
						emojiList = []
						emojiList.push(emojiInfo)
						if (emojiInfo.length < 993) {
							fieldStart = i
							f++
							embed.fields[f] = {}
							embed.fields[f].name = fieldStart + "-" + i + ":"
							embed.fields[f].value = emojiInfo
						}
					}
				})
		
				if (usedArrowButton) {
					msg.edit(emojiDesc, {embed: embed})
				} else {
					msg.channel.send(emojiDesc, {embed: embed})
						.then((msg) => {
							msg.react("‚¨Ö")
								.then(() => {
									msg.react("‚û°")
								})
								.catch(error => console.log(error))
						})
						.catch(error => console.log(error))
				}
			}
		
			return
		}
	},
	Sticker: {
		r: /^(—Å(—Ç–∏–∫–µ—Ä)?|sticker|—ç(–º–æ(–¥[–∂–∑]|–∂)–∏)?–ª–∏–Ω–∫|e(moji)?link)$/,
		v: true,
		async f (msg, args) {
			if (!args[0]) {
				msg.react("üìú")
				return
			}
		
			let emoji
		
			if (args[0].match(/^\d+$/g) && client.emojis.get(args[0])) {
				emoji = client.emojis.get(args[0])
			} else {
				let emojiName = s.getEmojiName(args[0])
				let guildName
				let guildCheck
				if (guildCheck = emojiName.match(/^([^:]+)(?::(\S+))$/)) {
					emojiName = guildCheck[1]
					guildName = guildCheck[2]
				}
				emoji = s.findEmoji(emojiName, guildName)
			}
		
			if (!emoji) {
				msg.react("604015450304806952")
				return
			}

			let imageLink = `https://cdn.discordapp.com/emojis/${emoji.id}.${emoji.animated ? "gif" : "png"}`

			await s.getMainColorFromImage(imageLink, color => {
				msg.channel.send({
					embed: {
						color: color,
						description: `<${emoji.animated ? "a" : ""}:${emoji.name}:${emoji.id}> ‚Äì ${emoji.name}`, 
						image: {
							url: imageLink
						}
					}
				})
			})
		}
	},
	Servers: {
		r: /^(—Å–µ—Ä–≤–µ—Ä[–∞—ã]|servers)[.!]?$/,
		f (msg, args) {
			let embed = {
				color: 0x888888,
				description: ""
			}
		
			let showAllServers = false
			if (msg.author.id == OWNER_ID && args[0] == "all") {
				showAllServers = true
			}
		
			let serversArray = []
			let counter = 0
			client.guilds.forEach(key => {
				if (showAllServers || key.emojis.size) {
					counter++
					serversArray.push(key.id + " | " + key.name)
				}
			})
			serversArray.sort((a, b) => {
				return Number(a.split(" | ")[0]) - Number(b.split(" | ")[0])
			})
			embed.description += `\`\`\`${serversArray.join("\n")}\`\`\``
			embed.title = counter + " —Å–µ—Ä–≤–µ—Ä–æ–≤"
		
			if (!showAllServers) {
				embed.title += " —Å —ç–º–æ–¥–∂–∏"
			}
		
			msg.author.send({embed: embed})
				.then(() => {
					s.envelope(msg)
				})
				.catch(error => console.log(error))
		}
	},
	Avatar: {
		r: /^(–∞–≤(–∞—Ç–∞—Ä(–∫–∞)?|–∫?–∞)|ava(tar)?|pfp)[.!]?$/,
		v: true,
		async f (msg, args, msgSimplifiedOrigCase) {
			let user
			if (args[0] == "random") {
				user = client.users.filter(u => u.avatar).random()
			} else if ( ["sb", "sbot", "—Å–±", "—Å–±–æ—Ç"].includes(args[0]) ) {
				user = client.users.get(BOT_ID)
			} else if (args[0]) {
				let username = s.getSimpleString(msgSimplifiedOrigCase.match(/\S+ (.+)/)[1])
				let result
				let usernameId
				// –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∞–π–¥–∏
				if (usernameId = username.match(/(?:<@\!?)?(\d+)>?/)) {
					await client.fetchUser(usernameId[1]).then(user => {
						result = user
					})
				// –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ç–µ–≥
				} else if (username.split("#")[1]) {
					client.users.forEach(u => {
						if (username == u.tag.toLowerCase()) {
							result = u
						}
					})
				} else {
					let isDisplayNameSuitable = false
					let isDisplayNameCanBeSuitable = false
			
					client.guilds.forEach(guild => {
						guild.members.forEach(member => {
							if (member.user.avatar) {
								if (username == s.getSimpleString(member.displayName)) {
									result = member.user
									isDisplayNameSuitable = true
								} else if (s.getSimpleString(member.displayName).startsWith(username)) {
									if (!isDisplayNameSuitable) {
										result = member.user
										isDisplayNameCanBeSuitable = true
									}
								} else if (member.nickname) {
									if (username == s.getSimpleString(member.user.username)) {
										if (!isDisplayNameSuitable && !isDisplayNameCanBeSuitable) {
											result = member.user
										}
									} else if (s.getSimpleString(member.user.username).startsWith(username)) {
										if (!result && !isDisplayNameSuitable && !isDisplayNameCanBeSuitable) {
											result = member.user
										}
									}
								}
							}
						})
					})		
				}
			
				user = result
			} else {
				user = msg.author
			}
		
			if (!(user && user.avatar)) {
				msg.react("604015450304806952")
				return
			}
		
			let fullSizeLink = user.avatarURL.split("?size=")[0] + "?size=2048"
		
			let link = user.avatarURL.split("?size=")[0] + "?size=128"

			await s.getMainColorFromImage(link, color => {
				msg.channel.send({embed: {
					color: color, 
					description: user.tag, 
					image: {
						url: fullSizeLink
					}
				}})
			})

		}
	},
	Invite: {
		r: /^(–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ|–∏–Ω–≤–∞–π—Ç|invite)[.!]?$/,
		f (msg) {
			msg.author.send("–¢—ã –º–æ–∂–µ—à—å –ø—É—Å—Ç–∏—Ç—å –º–µ–Ω—è –Ω–∞ —Å–≤–æ–π —Å–µ—Ä–≤–µ—Ä —Å –ø–æ–º–æ—â—å—é —ç—Ç–æ–π —Å—Å—ã–ª–∫–∏: \n<https://discordapp.com/api/oauth2/authorize?client_id=" + BOT_ID + "&scope=bot&permissions=0>")
				.then(() => {
					s.envelope(msg)
				})
				.catch(error => console.log(error))
		}
	},
	Homestuck: {
		r: /^(hs|—Ö—Å|—Ö–æ—É–º—Å—Ç–∞–∫|homestuck)[.!]?$/,
		v: true,
		async f (msg, args, msgSimplifiedOrigCase, usedArrowButton) {
			let page_number
			let contentText = ""

			let domain = 'https://www.homestuck.com'
			let hs_part_mark = "hs#"
			let text_location = "p.type-rg"
		
			let num = Number(args[0])

			if (args[0]) {
				if (num >= 1 && num <= 8130) {
					page_number = args[0]
				} else if (num > 8130) {
					page_number = num % 8130
				} else {
					return
				}
			} else {
				page_number = 1
			}

			if (args[1] == "2" || num > 8130) {
				domain = 'https://www.homestuck2.com'
				hs_part_mark = "hs2#"
				text_location = 'div.type-rg'
			}
		
			let page_link = domain + '/story/' + page_number
			let comic_number = hs_part_mark + page_number
			let got_error_already = false
			let embed_color = 0x249E28
		
			let comic_embed = {
				color: embed_color,
				author: {
					url: page_link,
					name: comic_number
				}
			}
		
			try {
				let hs = await got(page_link, {
					headers: {
						"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) Gecko/20100101 Firefox/62.0"
					}
				})
		
				let $ = Cheerio.load(hs.body)
		
				let content_container = $('div#content_container')
				let flash_div = $('div#o_flash-container')
		
				// detecting video
				let is_there_video = false
				let yt_link = ""
				let yt_link_code
		
				if (flash_div.length) {
					let yt_raw = flash_div.html().match(/\'youtubeid\', \'(.+)\'/)
					if (yt_raw) {
						yt_link_code = yt_raw[1]
					}
				} else {
					let yt_raw = $('iframe.ar-inner').attr('src')
					if (yt_raw) {
						yt_link_code = yt_raw.match(/embed\/(.+)/)[1]
					}
				}
				if (yt_link_code) {
					yt_link = `https://youtu.be/${yt_link_code}`
					is_there_video = true
				}
		
		
				if (is_there_video) {
					// send title, desc and video link
					comic_embed = {}
					contentText = comic_number + "\n" + yt_link
				} else {
					// getting title
					let comic_title = $('h2.type-hs-header').text()
					if (comic_title && !is_there_video) {
						comic_title = `${comic_title} (${comic_number})`
					} else {
						comic_title = comic_number
					}
					comic_embed.author.name = comic_title
		
					// getting description
					let desc = $(text_location).text().replace(/\ +/g, " ").replace(/^\s+/, "").replace(/\s+$/, "")
					let desc_limit = 2047
					if (desc.length > desc_limit) {
						desc = desc.substring(0, desc_limit) + "‚Ä¶"
					} else if (desc.length == 0) {
						desc = ""
					}
					comic_embed.description = desc
		
					// getting images
					let imgs
					let img_link = ""
					let is_img_from_flash = false
					if (content_container.length) {
						imgs = content_container.find('img.mar-x-auto.disp-bl')
						if (!imgs.length) {
							let imgs_raw = $('div.bg-scratch-mid-green.pad-t-lg').find('img')
							if (imgs_raw.length) {
								imgs = imgs_raw.attr('src')
								is_img_from_flash = true
							}
						}
					} else {
						imgs = $('img.mar-x-auto.disp-bl')
					}
					if (flash_div.length && !imgs.length) {
						let imgs_raw = flash_div.html().match(/\'altimgsrc\', \'(.+)\'/)
						if (imgs_raw) {
							imgs = imgs_raw[1]
							is_img_from_flash = true
						}
					}
					if (imgs.length) {
						// send title, image and desc
						if (is_img_from_flash) {
							img_link = `${domain}${imgs}`
						} else if (imgs.attr('src').startsWith("/")) {
							img_link = `${domain}${imgs.attr('src')}`
						} else {
							img_link = imgs.attr('src')
						}
		
						comic_embed.image = {url: img_link}
					} else {
						// send title and footer
						comic_embed.footer = {text: "It's probably interactive."}
					}
				}
			} catch (err) {
				if (err.statusCode === 404) {
					comic_embed.footer = {text: "It's probably missing page."}
				}
			}
			
			let embed = {embed: comic_embed}
			if (usedArrowButton) {
				if (contentText) {
					msg.edit(contentText, embed)
				} else {
					msg.edit(embed)
				}
			} else {
				let contentToSend = (contentText) ? contentText : embed
				msg.channel.send(contentToSend).then((msg) => {
					msg.react("‚¨Ö").then(() => {
						msg.react("‚û°").then(() => {
							msg.react("üîÉ")
						})
						.catch(error => console.log(error))
					})
					.catch(error => console.log(error))
				})
				.catch(error => console.log(error))
			}

		}
	},
	SnowflakeTime: {
		r: /^(—Å–Ω–µ–∂–∏–Ω–∫[–∞–∏]|sftime)[.!]?$/,
		f (msg, args) {
			let totalSFTimes = []
			args.forEach(arg => {
				if (arg.match(/\d{17,20}/)) {
					let totalMatches = arg.match(/\d{17,20}/g)
					for (let i in totalMatches) {
						let d = new Date(1420070400000 + Number(totalMatches[i]) / 4194304)
						if (!d.toJSON) {
							d = new Date(d)
						}
						d.setHours(d.getHours() + 3)
						totalSFTimes.push(`${d.toJSON().split(".")[0].replace(/T/, ' ')} –ú–°–ö`)
					}
				}
			})
			if (totalSFTimes) {
				msg.channel.send(totalSFTimes.join("\n"))
			}
		}
	},
	Stats: {
		r: /^(stats|—Å—Ç–∞—Ç—ã|—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞|–∞–ø(—Ç–∞–π–º)?|up(time)?)[.!]?$/,
		v: true,
		f (msg) {
			let uptimeResult
			let u = client.uptime
			if (u > 1000) {
				let diff = u
				let tarr = [1000, 60, 60, 24]
				for (let i in tarr) {
					let x = tarr[i]
					tarr[i] = diff % x
					diff = (diff - tarr[i]) / x
				}
				tarr.push(diff)
				tarr.shift()
				let warr = [
					['—Å–µ–∫—É–Ω–¥—É', '—Å–µ–∫—É–Ω–¥—ã', '—Å–µ–∫—É–Ω–¥'],
					['–º–∏–Ω—É—Ç—É', '–º–∏–Ω—É—Ç—ã', '–º–∏–Ω—É—Ç'],
					['—á–∞—Å', '—á–∞—Å–∞', '—á–∞—Å–æ–≤'],
					['–¥–µ–Ω—å', '–¥–Ω—è', '–¥–Ω–µ–π'],
				]
				let sarr = []
				for (let i = tarr.length - 1; i >= 0; i--) {
					if (!tarr[i]) {
						continue
					}
					sarr.push(tarr[i] + ' ' + s.pluralize(tarr[i], warr[i]))
				}
				uptimeResult = `–Ø —Ä–∞–±–æ—Ç–∞—é —É–∂–µ ${sarr.join(', ')}.`
			} else {
				uptimeResult = `–Ø —Ç–æ–ª—å–∫–æ –∑–∞—à—ë–ª.`
			}

			let subData = JSON.parse(fs.readFileSync('cinemadata.json'))
		
			const statsEmbed = {
				color: 0x888888,
				title: "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
				description: uptimeResult,
				footer: {
					text: `${process.env.npm_package_version} | üóÑ ${client.guilds.size} | üò∂ ${client.emojis.size} | üë• ${client.users.size} | üìΩÔ∏è ${subData["565291444705689612"].users.length} | ‚õ©Ô∏è ${subData["577130367304204288"].users.length}`
				}
			}
		
			msg.channel.send({embed: statsEmbed})
		}
	},
	When: {
		r: /^(–∫–æ–≥–¥–∞)[.!]?$/,
		v: true,
		f (msg, args, msgSimplifiedOrigCase) {
			if (!args[0]) {
				return
			}
		
			let questionOriginal = msgSimplifiedOrigCase.match(/\S+ ([\s\S]+)/)[1].replace(/[.!?]+$/, "")
			let question = s.getSimpleString(questionOriginal)
		
			let epochStart = 17999
			let epochEnd = 65573
			let T = epochEnd - epochStart
		
			let days = Math.floor(Math.pow(((s.hashCode(question) % T) / T), 6) * T) + epochStart
			if (question.match(/(–∂–µ–ª–µ–∑–Ω(–∞—è|–æ–π|—É—é) –¥–≤–µ—Ä(—å|–∏)|–∫–æ–Ω–µ—Ü —Å–≤–µ—Ç–∞|–∞—Ä–º–∞–≥–µ–¥–¥–æ–Ω|–∞–ø–æ–∫–∞–ª–∏–ø—Å–∏—Å)/)) {
				days = epochEnd
			}
		
			let whenEmbed = {
				title: "–ö–æ–≥–¥–∞ " + questionOriginal + "?",
			}
		
			let dateOptions = {year: "numeric", month: "long", day: "numeric"}
			let dateText
		
			if (days == epochStart) {
				dateText = "–°–µ–≥–æ–¥–Ω—è."
			} else if (days == epochStart + 1) {
				dateText = "–ó–∞–≤—Ç—Ä–∞."
			} else if (days > epochEnd - 1000 && days < epochEnd) {
				dateText = "–ù–∏–∫–æ–≥–¥–∞."
			} else if (question == "–∫–æ–≥–¥–∞") {
				dateText = "–¢–æ–≥–¥–∞."
			} else {
				dateText = new Intl.DateTimeFormat("ru", dateOptions).format(new Date(days*86400*1000))
			}
			whenEmbed.description = "üóì " + dateText
		
			msg.channel.send({embed: whenEmbed})
		}
	},
	IronDoor: {
		r: /^(–∂–µ–ª–µ–∑–Ω–∞—è–¥–≤–µ—Ä—å|–∂–¥)[.!]?$/,
		v: true,
		f (msg, args) {
			if (!args[0]) {
				return
			}
		
			let possibleAnswers = [
				"–ë–µ—Å—Å–ø–æ—Ä–Ω–æ.", 
				"–û–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ, –¥–∞.",
				"–ë–µ–∑ —Å–æ–º–Ω–µ–Ω–∏—è.",
				"–ö–æ–Ω–µ—á–Ω–æ.",
		
				"–î—É–º–∞—é, –¥–∞.",
				"–ù–∞–≤–µ—Ä–Ω–æ–µ.",
				"–í–ø–æ–ª–Ω–µ –≤–µ—Ä–æ—è—Ç–Ω–æ.",
				"–í–æ–∑–º–æ–∂–Ω–æ, —Ç–∞–∫ –∏ –µ—Å—Ç—å.",
				"–ê —Å–∞–º –∫–∞–∫ –¥—É–º–∞–µ—à—å?",
		
				"–•–ó, –≤–æ–æ–±—â–µ.",
				"–í—Å–µ–ª–µ–Ω–Ω–∞—è –Ω–µ –º–æ–∂–µ—Ç –ø–æ–¥—Å–∫–∞–∑–∞—Ç—å –º–Ω–µ —Å–µ–π—á–∞—Å.",
				"–ù–µ—è—Å–Ω–æ.",
				"–ü–æ–ø—Ä–æ–±—É–π —Å—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å –ø–æ-–¥—Ä—É–≥–æ–º—É.",
				"–ú–æ–∂–µ—Ç –±—ã—Ç—å.",
				"–ù–µ –º–æ–≥—É —Å–µ–π—á–∞—Å —Å–∫–∞–∑–∞—Ç—å —Ç–æ—á–Ω–æ.",
				"–ü–æ–ø—Ä–æ–±—É–π –ø–æ–¥—É–º–∞—Ç—å —Å–∞–º.",
				"–ß—Ç–æ –∑–∞ —Å—Ç—Ä–∞–Ω–Ω—ã–π –≤–æ–ø—Ä–æ—Å?",
				"–ù–µ –º–æ–≥—É —Å–∫–∞–∑–∞—Ç—å —Å–µ–π—á–∞—Å.",
				"–õ—É—á—à–µ –±—ã —Ç–µ–±–µ –Ω–µ –∑–Ω–∞—Ç—å –æ–± —ç—Ç–æ–º.",
				"–û—Ç–∫—É–¥–∞ –º–Ω–µ –∑–Ω–∞—Ç—å?",
				"50 –Ω–∞ 50.",
		
				"–°–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –Ω–µ—Ç.",
				"–î–∞ –≤—Ä—è–¥ –ª–∏.",
				"–ú–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω–æ.",
				"–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å - –æ–∫–æ–ª–æ–Ω—É–ª–µ–≤–∞—è.",
		
				"–ö–æ–Ω–µ—á–Ω–æ, –Ω–µ—Ç.",
				"–ú–æ–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –≥–æ–≤–æ—Ä—è—Ç: \"–Ω–µ—Ç\".",
				"–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å - –Ω—É–ª–µ–≤–∞—è.",
				"–í—Å–µ–ª–µ–Ω–Ω–∞—è —Ç–∞–∫ –Ω–µ –¥—É–º–∞–µ—Ç."
			]
		
			let embed = {
				author: {
					name: s.getRandomElem(possibleAnswers),
					icon_url: "https://i.imgur.com/P8IAywM.png"
				}
			}
		
			msg.channel.send({embed: embed})
		}
	},
	Three: {
		r: /^-?(\d)[.!]?$/,
		v: true,
		f (msg, args, msgSimplifiedOrigCase) {
			if (!args[0]) {
				args.unshift(msg.content.split(/\s+/).slice(-1)[0])
				s.autoreact(msg, args, false)
				return
			}
		
			let num = parseInt(msgSimplifiedOrigCase.split(" ")[0])
		
			if (!num && num !== 0) {
				return
			} else if (num > 7) {
				num = 7
			} else if (num < 1) {
				msg.channel.send("No emoji for you!")
				return
			}
		
			let emojiName = s.getEmojiName(args[0])
			let guildName
			let guildCheck
		
			if (guildCheck = emojiName.match(/^([^:]+)(?::(\S+))$/)) {
				emojiName = guildCheck[1]
				guildName = guildCheck[2]
			}
		
			let emoji = s.findEmoji(emojiName, guildName)
		
			if (!emoji) {
				msg.react('604015450304806952')
				return
			}

			let prefix = "<:"
			let postfix = "> "
			if (emoji.animated) {
				prefix = "<a:"
			}
		
			let e = prefix + emoji.name + ":" + emoji.id + postfix
			
			msg.channel.send(e.repeat(num))
		}
	},
	Rtfm: {
		r: /^(rtfm|man|docs?)[.!]?$/,
		async f (msg, args, msgSimplifiedOrigCase) {
			if (!args[0] || !args[1]) {
				msg.channel.send("–£–∫–∞–∂–∏—Ç–µ –≤ –∫–æ–º–∞–Ω–¥–µ, –∫–∞–∫–∏–µ –¥–æ–∫–∏ –≤–∞–º –Ω—É–∂–Ω—ã (js, py, jda) –∏ –∫–∞–∫–æ–π –º–µ—Ç–æ–¥/—Å–æ–±—ã—Ç–∏–µ –∏—â–∏—Ç–µ.")
				return
			}
		
			let lang = args[0]
			let query = msgSimplifiedOrigCase.split(" ")[2]
		
			let [, docsClass, docsMethod] = query.match(/^(\w+)(?:\.([\w\.]+))?/)
			docsClass = docsClass[0].toUpperCase() + docsClass.slice(1);
		
			let link
		
			if (["js", "javascript", "node", "nodejs", "discord.js"].includes(lang)) {
				link = `https://discord.js.org/#/docs/main/stable/class/${docsClass}`
				if (docsMethod) link += `?scrollTo=${docsMethod}`
			} else if (["py", "python", "discord.py"].includes(lang)) {
				if (docsClass.toLowerCase() == "commands") {
					link = `https://discordpy.readthedocs.io/en/latest/ext/commands/api.html#discord.ext.commands`
				} else if (docsClass.toLowerCase() == "tasks") {
					link = `https://discordpy.readthedocs.io/en/latest/ext/tasks/index.html#discord.ext.tasks`
				} else {
					link = `https://discordpy.readthedocs.io/en/latest/api.html#discord.${docsClass}`
				}
				if (docsMethod) link += `.${docsMethod}`
			} else if (["java", "jda"].includes(lang)) {
				let queryParts = query.split(".")
				if ( !["annotations", "bot", "core", "client", "webhook"].includes(queryParts[0]) ) {
					queryParts.unshift("core", "events")
				}
				let possibleEvent = queryParts[queryParts.length - 1]
				if (possibleEvent[0] == possibleEvent[0].toUpperCase() || possibleEvent.toLowerCase().endsWith("event")) {
					queryParts[queryParts.length - 1] = possibleEvent[0].toUpperCase() + possibleEvent.slice(1);
				} else {
					queryParts.push("package-summary")
				}
				for (let i = 0; i < queryParts.length - 1; i++) {
					queryParts[i] = queryParts[i].toLowerCase()
				}
		
				link = `https://ci.dv8tion.net/job/JDA/javadoc/net/dv8tion/jda/${queryParts.join("/")}.html`
			}
		
			try {
				await got(link).then(response => {
					let linkPartsPy = link.split("#")
					if (lang == "py" && linkPartsPy[1]) {
						if (!response.body.includes(`id=\"${linkPartsPy[1]}\"`)) throw "NotFoundError"
					} 
				})
				if (lang == "js") {
					await got("https://raw.githubusercontent.com/discordjs/discord.js/docs/stable.json").then(response => {
						if (!response.body.includes(`"path":"src/structures"}},{"name":"${docsClass}"`)) throw "NotFoundError"
						if (docsMethod) {
							if (!response.body.includes(`"path":"src/structures"}},{"name":"${docsMethod}"`)) throw "NotFoundError"
						}
					})
				}
				msg.channel.send(`üìú <${link}>`)
			} catch (err) {
				msg.channel.send(`–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –Ω–∞ —Ç–∞–∫–æ–µ –Ω–µ—Ç...`)
			}
			
		}
	},
	Palette: {
		r: /^(–ø–∞–ª–∏—Ç—Ä–∞|palette)[.!]?$/,
		v: true,
		async f (msg) {
			if (!msg.attachments.size) {
				msg.channel.send("–ù—É–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É –∫ —Å–æ–æ–±—â–µ–Ω–∏—é!")
				return
			}
			msg.attachments.forEach(async (att) => {
				let max = 128
				let w = max
				let h = max
				if (att.width > att.height) {
					h = Math.round(att.height / (att.width / max))
				} else {
					w = Math.round(att.width / (att.height / max))
				}
				let imagePreview = `https://media.discordapp.net/attachments/${msg.channel.id}/${att.id}/${att.filename}?width=${w}&height=${h}`

				await s.getMainColorFromImage(imagePreview, (color, palette) => {
					let hexColors = []

					let canvasW = 350
					let canvasH = 50
					let segmentW = Math.round(canvasW / palette.length) * 2
					let segmentH = Math.round(canvasH / 2)

					const canvas = Canvas.createCanvas(canvasW, canvasH)
					const ctx = canvas.getContext('2d')
					for (let i = 0; i < palette.length; i++) {
						let hex = palette[i].toString(16)
						let tempHex = `00000${hex}`
						hex = `#${tempHex.slice(-6)}`
						hexColors.push(hex)
						let x = i % 5
						let y = Math.floor(i / 5)
						ctx.fillStyle = hex
						ctx.fillRect(segmentW*x, segmentH*y, segmentW, segmentH)
					}
					const buf = canvas.toBuffer('image/png')

					msg.channel.send(`\`\`\`${hexColors.slice(0,5).join(" ")}\n${hexColors.slice(5,10).join(" ")}\`\`\``, {
						files: [{
							attachment: buf,
							name: "palette.png"
						}]
					})
				})
			})

		}
	},
	Recolor: {
		r: /^(—Ä–µ–∫–æ–ª–æ—Ä|recolor)[.!]?$/,
		v: true,
		async f (msg, args) {
			if (!args.length) {
				msg.channel.send("–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —Ü–≤–µ—Ç–∞! –ù–∞–ø—Ä–∏–º–µ—Ä, `#d51a24 #7ca4af #f8dfa8 #05324a`")
				return
			}
			if (!msg.attachments.size) {
				msg.channel.send("–ù—É–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É –∫ —Å–æ–æ–±—â–µ–Ω–∏—é!")
				return
			}
			let pal = []
			for (let i = 0; i < args.length; i++) {
				pal.push(parseInt(args[i].slice(-6), 16)*256 + 255)
			}
			msg.attachments.forEach(async (att) => {
				let max = 1024
				let w = max
				let h = max
				if (att.width > att.height) {
					h = Math.round(att.height / (att.width / max))
				} else {
					w = Math.round(att.width / (att.height / max))
				}
				let imagePreview = `https://media.discordapp.net/attachments/${msg.channel.id}/${att.id}/${att.filename}?width=${w}&height=${h}`

				await s.recolorByPalette(imagePreview, pal, buf => {
					msg.channel.send({
						files: [{
							attachment: buf,
							name: "recolored.png"
						}]
					})
				})
			})

		}
	},
	Kana: {
		r: /^(kana|–∫–∞–Ω–∞)[.!]?$/,
		v: true,
		async f (msg, args) {
			let k = hiragana
			if (["katakana", "–∫–∞—Ç–∞–∫–∞–Ω–∞"].includes(args[0])) {
				k = katakana
			}

			let firstQuestion = true
			let botMessage
			let isGameRunning = true

			let score = 0
			let rounds = 0
			let wrongMap = []

			let secondsToWait = 15
			if (args[1] && Number(args[1])) {
				secondsToWait = Number(args[1])
			}

			let buttons = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£"]
			const filter = (reaction, user) => buttons.includes(reaction.emoji.name) && user.id == msg.author.id;
			
			while (isGameRunning) {

				let con = Math.floor(k.syl.length*Math.random())
				let vow = Math.floor(k.syl[con].length*Math.random())

				let res = k.syl[con][vow]

				let pos = Math.floor(4*Math.random())

				let crow = [...kanalat[con]]
				let reslat = crow[vow]

				let opts = crow
				opts.splice(vow, 1)
				opts = s.shuffle(opts).slice(0,3)
				
				opts.splice(pos, 0, reslat)

				const embed = {
					title: res,
					description: `${opts.join(" ").toUpperCase()} \n\n–£ –≤–∞—Å ${secondsToWait} —Å–µ–∫—É–Ω–¥!\n[–®–ø–∞—Ä–≥–∞–ª–∫–∞](https://docs.google.com/spreadsheets/d/1GdpF_ameYIvhFTT2Ji_MNisDS7qCLENoxMllR59q6Zg/edit?usp=drivesdk)`,
					footer: {
						icon_url: msg.author.avatarURL,
						text: `${msg.author.tag} - ${score}/${rounds}`
					}
				}
				
				if (firstQuestion) {
					await msg.channel.send({embed: embed}).then(async (m) => {
						firstQuestion = false
						botMessage = m

						for (let i = 0; i < 4; i++) {
							await m.react(buttons[i])
						}
					})
					.catch(error => console.log(error))
				} else {
					await botMessage.edit({embed: embed})
				}
				
				await botMessage.awaitReactions(filter, { max: 1, time: secondsToWait*1000 })
					.then(collected => {
						const reaction = collected.first()
						if (botMessage.channel.type == "text" && botMessage.member.hasPermission('MANAGE_MESSAGES')) {
							reaction.remove(msg.author.id)
						}
						if (buttons.indexOf(reaction.emoji.name) == pos) {
							score++
						} else {
							wrongMap[con] = []
							wrongMap[con][vow] = true
						}
					})
					.catch(collected => {
						isGameRunning = false
						let wrongGuesses = []
						for (let i = 0; i < wrongMap.length; i++) {
							if (wrongMap[i]) {
								for (let j = 0; j < wrongMap[i].length; j++) {
									if (wrongMap[i][j]) {
										wrongGuesses.push(`${k.syl[i][j]} ||${kanalat[i][j]}||`)
									}
								}
							}
						}
						let gameoverText = "–í—Ä–µ–º—è –≤—ã—à–ª–æ!"
						if (wrongGuesses.length) {
							gameoverText += ` \n–ü–æ–¥—É—á–∏—Ç—å: ${wrongGuesses.join(" ")}`
						}
						msg.reply(gameoverText)
					});

				rounds++
			}	

		}
	},
	Jwords: {
		r: /^(jwords|jlpt|kanji|–∫–∞–Ω(–¥?[–∂–∑])–∏)[.!]?$/,
		v: true,
		async f (msg, args) {

			let isGameRunning = true
			if (msg.channel.type == "dm") {
				userDB[msg.author.id].learningKanji = true
			}

			let firstQuestion = true
			let botMessage
			let userAnswerMessage
			let gameChannel = msg.channel

			let messageForPreviousGuess = 'Let\'s begin!'

			let score = 0
			let rounds = 0
			let wrongSet = new Set()

			let secondsToWait = 15
			if (args[0] && Number(args[0])) {
				secondsToWait = Number(args[0])
			}

			const filter = (m) => m.author.id == msg.author.id;

			let userPath = `jap_users/${msg.author.id}.json`
			let userData
			if (fs.existsSync(userPath)) {
				userData = JSON.parse(fs.readFileSync(`jap_users/${msg.author.id}.json`))
			} else {
				userData = {
					"studied": [],
					"problemed": {}
				}
			}

			let studied = new Set(userData.studied)

			while (isGameRunning) {

				let num
				let probArr = Object.keys(userData.problemed)

				if (!probArr.length || (studied.size + probArr.length) % 5) {
					num = Math.floor(Math.random() * kanji.length)
				} else {
					if (Math.random() > 0.2 || !studied.size) {
						num = s.getRandomElem(probArr)
					} else {
						num = s.getRandomElem(Array.from(studied))
					}
				}

				let k = kanji[num]

				let hir = [...hiragana.syl]
				hir.push('„ÇÉ„ÇÖ„Çá')
				let kat = [...katakana.syl]
				kat.push('„É£„É•„Éß')
				let lat = [...kanalat]
				lat.push(['ya', 'yu', 'yo'])

				let romaji = []

				for (let i = 0; i < k.r.length; i++) {
					let rvar = k.r[i]
					let rvarRomaji = ''
					let tsuRepeating = false
					for (let j = 0; j < rvar.length; j++) {
						if (['„Å£', '„ÉÉ'].includes(rvar[j])) {
							tsuRepeating = true
							continue;
						}
						if (rvar[j] == '„Éº') {
							rvarRomaji += rvarRomaji.slice(-1)
							continue;
						}
						for (let x = 0; x < hir.length; x++) {
							for (let y = 0; y < hir[x].length; y++) {
								if ([hir[x][y], kat[x][y]].includes(rvar[j])) {
									if (tsuRepeating) {
										rvarRomaji += lat[x][y][0]
										tsuRepeating = false
									}
									if (x == hir.length - 1) { // check if it's lowered vowel
										if (rvarRomaji.slice(-1) != 'n') {
											rvarRomaji = rvarRomaji.slice(0, -1)
										}
										if (rvarRomaji.match(/(sh|ch|j)$/)) {
											rvarRomaji += lat[x][y][1]
										} else {
											rvarRomaji += lat[x][y]
										}
									} else {
										rvarRomaji += lat[x][y]
									}
								}
							}
						}
					}
					romaji.push(rvarRomaji)
				}

				// canvas start

				const canvas = Canvas.createCanvas(k.s.length*160+40, 200)
				const ctx = canvas.getContext('2d')
	
				let { body: imageInfo } = await got(`https://neko-love.xyz/api/v1/neko`, { json: true })
				if (imageInfo.error) throw Error(imageInfo.error)
				const bg = await Canvas.loadImage(imageInfo.url)
	
				const bgw = bg.width
				const bgh = bg.height
				const canw = canvas.width
				const canh = canvas.height
	
				const bgRatio = bgw/bgh
				const canvasRatio = canw/canh
	
				if (bgRatio < canvasRatio) {
					ctx.drawImage(bg, 0, (bgh-bgw/canvasRatio)/2, bgw, bgw/canvasRatio, 0, 0, canw, canh)
				} else {
					ctx.drawImage(bg, (bgw-bgh*canvasRatio)/2, 0, bgh*canvasRatio, bgh, 0, 0, canw, canh)
				}
				
	
				ctx.font = `160px "KosugiMaru"`
				ctx.textAlign = "center"
				ctx.textBaseline = "middle"
				ctx.fillStyle = 'rgba(114, 137, 218, 0.3)';
				ctx.fillRect(0, 0, canw, canh);
				ctx.fillStyle = 'white'
				ctx.fillText(k.s, canw/2, canh/2)
				ctx.strokeStyle = 'black';
				ctx.lineWidth = 1;
				ctx.strokeText(k.s, canw/2, canh/2);
				const buf = canvas.toBuffer('image/png')
				
				// canvas end

				const embed = {
					title: messageForPreviousGuess,
					description: `You have ${secondsToWait} seconds!\n[jisho](https://jisho.org/search/%23kanji%20${k.s}) \n\n||\` ${k.r.join(", ")}, ${k.m[0]} \`||  `,
					image: {
						url: 'attachment://neko.png'
					},
					footer: {
						icon_url: msg.author.avatarURL,
						text: `${msg.author.tag} - ${score}/${rounds}`
					}
				}

				let botmsgToDelete = botMessage
				await gameChannel.send({
					embed: embed,
					files: [{
						attachment: buf,
						name: 'neko.png'
					}]
				}).then(async (m) => {
					botMessage = m
					gameChannel.stopTyping()
				})
				.catch(error => console.log(error))

				if (!firstQuestion && s.deleteUserMessage(userAnswerMessage, 0)) {
					await botmsgToDelete.delete()
				} else {
					firstQuestion = false
				}
				
				await gameChannel.awaitMessages(filter, { max: 1, time: secondsToWait*1000 })
					.then(collected => {
						gameChannel.startTyping()
						const m = collected.first()
						userAnswerMessage = m
						if (k.r.includes(m.content) || romaji.includes(m.content) || k.m.includes(m.content)) {
							score++
							messageForPreviousGuess = `Right!`

							if (!studied.has(num)) {
								let p = userData.problemed[num]

								p = (p) ? ++p : 1
								
								if (p == 7) {
									studied.add(num)
									delete userData.problemed[num]
								} else {
									userData.problemed[num] = p
								}
							}
							
						} else {
							wrongSet.add(k.s)
							messageForPreviousGuess = `Nope.`

							userData.problemed[num] = 0
							studied.delete(num)
						}
					})
					.catch(collected => {
						isGameRunning = false
						userDB[msg.author.id].learningKanji = false
						const gameoverEmbed = {
							title: "Time's up!"
						}
						if (rounds) {
							gameoverEmbed.description = `Result: ${(score/rounds*100).toFixed(2)}%`
							if (wrongSet.size) {
								gameoverEmbed.description += ` \nTo learn: ${Array.from(wrongSet).map(x=>'['+x+']'+'(https://jisho.org/search/%23kanji%20'+x+')').join("„ÄÄ")}`
							}
						}

						msg.reply({embed: gameoverEmbed})

						userData.studied = Array.from(studied)
						fs.writeFile(userPath, JSON.stringify(userData, null, 2), err => {
							if (err) {
								console.log("error on writing to file!")
							}
						})
					});

				rounds++
			}	

		}
	},
	Sub: {
		r: /^((un)?sub|(–∞–Ω)?—Å–∞–±)[.!]?$/,
		v: false,
		async f (msg, args, msgSimplifiedOrigCase) {
			if (!args[0]) {
				return
			}
			let isUserSubbing = true
			if (msgSimplifiedOrigCase.match(/^(unsub|–∞–Ω—Å–∞–±)/)) {
				isUserSubbing = false
			}
			let subTarget
			switch (args[0]) {
				case "–∫–∏–Ω–æ":
				case "kino":
					subTarget = "565291444705689612"
					break;
				case "–∞–Ω–∏–º–µ":
				case "anime":
					subTarget = "577130367304204288"
					break;
				default:
					break;
			}
			let data = JSON.parse(fs.readFileSync('cinemadata.json'))
			let users = new Set(data[subTarget].users)
			let subName = data[subTarget].name
			let uid = msg.author.id
			if (isUserSubbing) {
				if (users.has(uid)) {
					msg.reply(`–í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ ${subName}!`)
				} else {
					users.add(uid)
					data[subTarget].users = Array.from(users)
					fs.writeFile("cinemadata.json", JSON.stringify(data, null, 2), err => {
						if (!err) {
							msg.reply(`–¢–µ–ø–µ—Ä—å –≤—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ ${subName}!`)
						}
					})
				}
			} else {
				if (!users.has(uid)) {
					msg.reply(`–í—ã –∏ —Ç–∞–∫ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ ${subName}!`)
				} else {
					users.delete(uid)
					data[subTarget].users = Array.from(users)
					fs.writeFile("cinemadata.json", JSON.stringify(data, null, 2), err => {
						if (!err) {
							msg.reply(`–¢–µ–ø–µ—Ä—å –≤—ã –æ—Ç–ø–∏—Å–∞–Ω—ã –æ—Ç ${subName}!`)
						}
					})
				}
			}
		}
	}
}
